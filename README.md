# chatsystem
This Advanced Secure Programming assignment is designed to help students apply the theoretical concepts covered in the lectures/RangeForce and learn about practice secure programming. This assignment is a group work assignment.  In groups of 2-4 students, you will engage in a hands-on assignment that requires the design, development, and evaluation of a secure overlay chat system utilising a standardised protocol created by all the students in this class. This system must adhere to class-specified protocol, have a secure implementation, have the secured implementation intentionally and ethically "backdoored", and then be tested in a controlled code review process. The course concludes with a friendly hackathon exercise.

Currently the code is only tested with python 3.12.

## Execution

Installation
```
pip install -r requirements.txt

pip install websockets
``````

Open your terminal, navigate to the folder containing your main.html, and run:

```
python3 -m http.server 8000
```

Then open browser then go to:
```
http://localhost:8000/main.html
```

Open your terminal, navigate to the `src` and run:
```
python3 server.py
```
Then open another terminal to run:
```
python3 client.py
```

## Todo
- Counter and signature in the message [x]
- Multiple servers [x]
- File transfer [x]
- Security backdoor [x]
- Testing
- Error handeling
- Serverside message verification
- Fix up terminal output

## Some Notes
- Reading user input should be an asychronous operation to avoid blocking the whole process
- Sometimes the tests may fail due to incomplete setup for the server. Increase the sleep time in pytest fixture `run_server` to allow the setup thread to finish.
- You need to request client list on client side when everyone joins before you can begin sending messages.

## Running
Once the server are running, they need to be given an address and a port, this is defaulted to `127.0.0.1` and port `8000`. It is reccomended to stay on `127.0.0.1` for the purposes of testing. by hitting enter for both options you will be presented with the base64 encoding of the server's public key and wil be asked if you would like to add any of the other servers to the neighbourhood. If you hit "y" you will then be asked to provide the address of a server in the neighbourhood which should be in the form `{address}:{port}`. Once enter you will then be asked to enter that server's base64 public key, this needs to be copy and pasted from the cli of the neighbouring server. 

### Example workflow for making a neighbourhood of 2 servers 
- Open up 2 terminals
- in terminal 1 run `server.py`
- in terminal 1 leave address on `127.0.0.1` and hit enter
- in terminal 1 leave port on `8000` and hit enter
- in terminal 2 run `server.py`
- in terminal 2 leave address on `127.0.0.1` and hit enter
- in terminal 2 change port to `8001` and hit enter
- in terminal 2 input the neighbouting addres as `127.0.0.1:8000` and hit enter
- copy the public key initally generated by terminal 1 into the input of terminal 2 and click enter.
- in terminal 2 hit enter until the websocket begins running
- in terminal 1 input the neighbouting addres as `127.0.0.1:8001` and hit enter
- copy the public key initally generated by terminal 2 into the input of terminal 1 and click enter.
- in terminal 2 hit enter until the websocket begins running

- Given you did all those steps properly, the servers are now connected.

- You can now add clients to terminals 1 and 2 seperately and talk to each other.

## Test Overview

### Running the Tests

To run the tests, use the following command:

```bash
pytest tests
```

Use -k option for running a single test. For example,
```bash
pytest -k test_public_chat
```

### test_one_server.py
The test suite is designed to verify the correctness of client-server interactions in a WebSocket environment with one server.

#### Test Fixtures
   - **`run_server`**: This fixture initializes and runs the WebSocket server in a separate thread, ensuring it is available for all test cases. After the tests complete, the server is gracefully shut down.

#### Test Cases

- `test_single_client_send_hello_and_request_client_list`  
  This test simulates a single client connecting to the server, sending a "hello" message, and requesting the client list from the server. It asserts that the server responds with a list containing only the connecting client.

- `test_single_client_send_message_to_self`  
  A client connects to the server and sends a chat message to itself. The test ensures that the client receives its own message correctly, validating that the message content and sender are correct.

- `test_single_client_send_message_to_another_client`  
  Two clients connect to the server. Client 2 sends a message to Client 1, and the test verifies that Client 1 receives the message. The correct content and sender details are asserted.

- `test_message_from_unknown_sender`  
  This test ensures that if a message is received from an unknown client (i.e., a client whose public key is not cached), the system cannot verify the signature. The test confirms that both the message and sender are `None`.

- `test_third_client_does_not_receive_private_message`  
  When one client sends a private message to another, a third connected client should not receive the message. This test checks that only the intended recipient gets the message, and the third client receives no communication.

- `test_send_message_to_multiple_clients`  
  A client sends a message to multiple recipients (Client 1 and Client 3). The test confirms that both clients receive the message with the correct sender details.

- `test_multiturn_dialogue`  
  In this test, two clients engage in a multi-turn dialogue, each sending multiple messages. The test ensures that all messages are exchanged correctly and that both clients receive the expected sequence of messages.

- `test_public_chat`  
  This test simulates a public chat where a message is sent to all connected clients. The test ensures that all clients receive the public message from the sender.

- `test_check_for_relay_attack`  
  This test simulates a replay attack scenario where the same message is sent twice with an invalid counter. It verifies that the receiving client detects the replay attack and only processes the valid message.

- `test_send_message_to_offline_client`  
  The test validates that sending a message to an offline client does not cause any errors. The client attempts to send a message after the recipient has disconnected, ensuring that no exception occurs.

### test_multi_server.py
The tests verify the correctness of communication with more than one server.

#### Test Cases
- `test_client_send_message_to_another_client_on_two_servers`:
  Two clients connect to two different servers in a neighbourhood. Client 2 sends a message to Client 1, and the test verifies that Client 1 receives the message. The correct content and sender details are asserted.

### test_file_transfer.py
The test suite verifies both the success and error scenarios for uploading and retrieving files.

#### Test Cases
- `test_upload_file_success`  
  Tests successful file upload and verifies that the file is saved in the correct location.

- `test_upload_file_no_file`  
  Tests the scenario where no file is provided in the request.

- `test_upload_file_no_filename`  
  Tests the scenario where a file is uploaded with an empty filename.

- `test_get_file_success`  
  Verifies that an uploaded file can be successfully downloaded.

- `test_get_file_not_found`  
  Tests the case where a non-existent file is requested.

### client_simulator.py

The `ClientSimulator` class, defined in `tests/client_simulator.py`, is used to simulate client behavior during tests. It provides methods for setting up WebSocket connections, sending and receiving messages, and handling more advanced scenarios such as replay attacks and multi-client message distribution.

- `setup()`: Initializes a simulated client, sends a hello message, and requests the client list from the server. It also handles synchronization between multiple clients.
- `quit()`: Closes the WebSocket connection.
- `recv_message()`: Listens for incoming messages and extracts chat or public chat messages.
- `recv_multiple_messages()`: Waits for a specified number of messages to be received.
- `send_message()`: Sends either a private or public chat message to other clients.
- `simulate_relay_attack()`: Simulates a replay attack by sending a message with an invalid counter.
- `send_multiple_messages_and_listen()`: Sends multiple messages and listens for responses from other clients.